set textwidth=100
set nohlsearch
set nocp
set shiftwidth=2
set expandtab
set smarttab
set sts=2
set ts=2
set colorcolumn=101
set number
set timeoutlen=1000 ttimeoutlen=0 "no delay when a key is pressed (mainly for escape)
set mouse=a
set shortmess+=S
set ic
set autowriteall
autocmd FileType * set fo+=t
autocmd FileType latex,tex,md,markdown,text setlocal spell
syntax enable

if !exists('g:vscode')
  set background=dark
  colorscheme solarized
  set cursorline
  "set cursorcolumn
  set noshowmode

  " Coq filetype setup
  au BufRead,BufNewFile *.v set filetype=coq
  autocmd Filetype coq nnoremap <leader>cq :CoqRunToCursor<CR>

  "" vimtex
  "let g:tex_comment_nospell = 1
  "let g:vimtex_quickfix_open_on_warning = 0
  "nnoremap <leader>c :VimtexCompile<CR>
  "let g:vimtex_syntax_conceal_disable=1
  "let g:vimtex_compiler_progname = 'nvr'

  " indentLine
  let g:indentLine_fileTypeExclude = ['tex', 'markdown']
  let g:vim_json_conceal = 0
  let g:markdown_syntax_conceal = 0

  " ALE
  let g:ale_completion_enabled = 1
  let g:ale_linters = { 'cpp': ['clangtidy', 'clang'], 'c': ['clangtidy', 'clang'],
        \ 'cmake': ['cmake_lint', 'cmake'], 'python': ['flake8'], 'sh': ['shellcheck'],
        \ 'rust': ['analyzer'], 'tex': ['lacheck'] }
  let g:ale_fixers = { 'cpp': ['clang-format'], 'c': ['clang-format'], 'cmake': ['cmakeformat'],
        \ 'rust': ['rustfmt'], 'python': ['autopep8', 'black'],
        \ '*': ['remove_trailing_lines', 'trim_whitespace'] }
  let g:ale_rust_cargo_use_clippy = 1
  let g:ale_fix_on_save = 1
  set showtabline=2
  let g:lightline#bufferline#unnamed = '[No Name]'
  let g:lightline#bufferline#enable_devicons = 1
  let g:lightline = {
        \ 'colorscheme': 'solarizedmine',
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filename', 'modified' ] ],
        \   'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'fileformat', 'fileencoding', 'filetype'],
        \              [ 'linter_checking', 'linter_errors', 'linter_warnings', 'linter_infos',
        \                'linter_ok' ] ],
        \ },
        \ 'tabline': { 'left': [ [ 'buffers' ] ], 'right': [ ], },
        \ 'component_expand': {
        \   'buffers': 'lightline#bufferline#buffers',
        \   'linter_checking': 'lightline#ale#checking',
        \   'linter_infos': 'lightline#ale#infos',
        \   'linter_warnings': 'lightline#ale#warnings',
        \   'linter_errors': 'lightline#ale#errors',
        \   'linter_ok': 'lightline#ale#ok',
        \ },
        \ 'component_type': {
        \   'buffers': 'tabsel',
        \   'linter_checking': 'right',
        \   'linter_infos': 'right',
        \   'linter_warnings': 'warning',
        \   'linter_errors': 'error',
        \   'linter_ok': 'right',
        \ },
  \ }
  let g:rainbow_active = 1
  let g:sneak#label = 1
  let g:sneak#use_ic_scs = 1
  let g:highlightedyank_highlight_duration = 300

  """ Enabling fzf
  set rtp+=/opt/homebrew/opt/fzf
  "nnoremap <leader>f :Files<CR>

  "" Tagbar
  "function! OpenTagbarIfTags()
  "    if filereadable("tags")
  "        :execute "TagbarOpen"
  "    endif
  "endfunction
  "nnoremap <leader>t :TagbarToggle<CR>
  "let g:tagbar_autoclose = 1

  "" CoC settings
  "" TextEdit might fail if hidden is not set.
  "set hidden

  "" Some servers have issues with backup files, see #649.
  "set nobackup
  "set nowritebackup

  "" Give more space for displaying messages.
  "set cmdheight=2

  "" Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
  "" delays and poor user experience.
  "set updatetime=300

  "" Don't pass messages to |ins-completion-menu|.
  "set shortmess+=c

  "" Always show the signcolumn, otherwise it would shift the text each time
  "" diagnostics appear/become resolved.
  "if has("patch-8.1.1564")
  "  " Recently vim can merge signcolumn and number column into one
  "  set signcolumn=number
  "else
  "  set signcolumn=yes
  "endif

  " Use tab for trigger completion with characters ahead and navigate.
  " NOTE: There's always complete item selected by default, you may want to enable
  " no select by `"suggest.noselect": true` in your configuration file.
  " NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
  " other plugin before putting this into your config.
  inoremap <silent><expr> <TAB>
        \ coc#pum#visible() ? coc#pum#next(1) :
        \ CheckBackspace() ? "\<Tab>" :
        \ coc#refresh()
  inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"

  function! CheckBackspace() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~# '\s'
  endfunction

  "" Use <c-space> to trigger completion.
  "if has('nvim')
  "  inoremap <silent><expr> <c-space> coc#refresh()
  "else
  "  inoremap <silent><expr> <c-@> coc#refresh()
  "endif

  " Make <CR> to accept selected completion item or notify coc.nvim to format
  " <C-g>u breaks current undo, please make your own choice.
  inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                                \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

  "" GoTo code navigation.
  "nmap <leader>gd <Plug>(coc-definition)
  "nmap <leader>gy <Plug>(coc-type-definition)
  "nmap <leader>gi <Plug>(coc-implementation)
  "nmap <leader>gr <Plug>(coc-references)

  "" Use K to show documentation in preview window.
  "nnoremap <silent> K :call ShowDocumentation()<CR>

  "function! ShowDocumentation()
  "  if CocAction('hasProvider', 'hover')
  "    call CocActionAsync('doHover')
  "  else
  "    call feedkeys('K', 'in')
  "  endif
  "endfunction

  "" Symbol renaming.
  "nmap <leader>rn <Plug>(coc-rename)

  " Remap <C-f> and <C-b> for scroll float windows/popups.
  if has('nvim-0.4.0') || has('patch-8.2.0750')
    nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
    nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
    inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
    inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
    vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
    vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
  endif

  function! CleanEmptyBuffers()
    let buffers = filter(range(1, bufnr('$')), 'buflisted(v:val) && empty(bufname(v:val)) && bufwinnr(v:val)<0 && !getbufvar(v:val, "&mod")')
    if !empty(buffers)
        exe 'bw ' . join(buffers, ' ')
    endif
  endfunction
  autocmd BufEnter * call CleanEmptyBuffers()

  lua require('config')
endif
